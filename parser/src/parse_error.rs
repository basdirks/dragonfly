use std::{
    error::Error,
    fmt::{
        self,
        Display,
        Formatter,
    },
};

/// Low-level parsing errors.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ParseError {
    /// A custom error.
    Custom {
        /// A description of the error.
        message: String,
    },
    /// Unexpected end of file.
    UnexpectedEof,
    /// The first character of the input can not be parsed.
    ///
    /// aka `ParseError::DaBoiIsNotHappyWithThisOne` -- @Fecony
    UnexpectedChar {
        /// The character that is found.
        actual: char,
        /// A description of the predicate.
        message: String,
    },
    /// None of the given parsers matches the input.
    UnmatchedChoice {
        /// The errors generated by each parser.
        errors: Vec<ParseError>,
    },
    /// The input does not match the given string literal.
    UnmatchedLiteral {
        /// The expected string literal.
        expected: String,
    },
}

impl ParseError {
    /// Create a new `Custom` error.
    ///
    /// # Arguments
    ///
    /// * `message` - A description of the error.
    #[must_use]
    pub fn custom<S>(message: S) -> Self
    where
        S: Into<String>,
    {
        Self::Custom {
            message: message.into(),
        }
    }

    /// Create a new `UnexpectedChar` error.
    ///
    /// # Arguments
    ///
    /// * `actual` - The character that is found.
    /// * `message` - A description of the predicate.
    #[must_use]
    pub fn unexpected_char<S>(
        actual: char,
        message: S,
    ) -> Self
    where
        S: Into<String>,
    {
        Self::UnexpectedChar {
            actual,
            message: message.into(),
        }
    }

    /// Create a new `UnmatchedChoice` error.
    ///
    /// # Arguments
    ///
    /// * `errors` - The errors generated by each parser.
    #[must_use]
    pub fn unmatched_choice<T>(errors: T) -> Self
    where
        T: Into<Vec<Self>>,
    {
        Self::UnmatchedChoice {
            errors: errors.into(),
        }
    }

    /// Create a new `UnmatchedLiteral` error.
    ///
    /// # Arguments
    ///
    /// * `expected` - The expected string literal.
    #[must_use]
    pub fn unmatched_literal<S>(expected: S) -> Self
    where
        S: Into<String>,
    {
        Self::UnmatchedLiteral {
            expected: expected.into(),
        }
    }
}

impl Display for ParseError {
    fn fmt(
        &self,
        f: &mut Formatter<'_>,
    ) -> fmt::Result {
        match self {
            Self::Custom { message } => {
                write!(f, "{message}")
            }
            Self::UnexpectedEof => write!(f, "Unexpected end of file"),
            Self::UnexpectedChar { actual, message } => {
                write!(f, "Unexpected character '{actual}': {message}")
            }
            Self::UnmatchedChoice { errors } => {
                let error_count = errors.len();

                writeln!(f, "Unmatched choice:")?;

                for (i, error) in errors.iter().enumerate() {
                    let i = i + 1;

                    if i == error_count {
                        write!(f, "{i}. {error}")?;
                    } else {
                        writeln!(f, "{i}. {error}")?;
                    }
                }

                Ok(())
            }
            Self::UnmatchedLiteral { expected } => {
                write!(f, "Unmatched literal: {expected}")
            }
        }
    }
}

impl Error for ParseError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            Self::UnexpectedChar { .. }
            | Self::UnexpectedEof
            | Self::Custom { .. }
            | Self::UnmatchedLiteral { .. } => None,
            Self::UnmatchedChoice { errors } => {
                #[allow(clippy::option_if_let_else)]
                if let Some(error) = errors.first() {
                    Some(error)
                } else {
                    None
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_display_custom_error() {
        assert_eq!(ParseError::custom("foo").to_string(), "foo");
    }

    #[test]
    fn test_display_unexpected_eof_error() {
        assert_eq!(
            ParseError::UnexpectedEof.to_string(),
            "Unexpected end of file"
        );
    }

    #[test]
    fn test_display_unexpected_char_error() {
        assert_eq!(
            ParseError::unexpected_char('a', "foo").to_string(),
            "Unexpected character 'a': foo"
        );
    }

    #[test]
    fn test_display_unmatched_choice_error() {
        assert_eq!(
            ParseError::unmatched_choice([
                ParseError::custom("foo"),
                ParseError::UnexpectedEof,
            ])
            .to_string(),
            "
            
Unmatched choice:
1. foo
2. Unexpected end of file

"
            .trim()
        );
    }

    #[test]
    fn test_display_unmatched_literal_error() {
        assert_eq!(
            ParseError::unmatched_literal("foo").to_string(),
            "Unmatched literal: foo"
        );
    }

    #[test]
    fn test_source_unexpected_char_error() {
        assert!(ParseError::unexpected_char('a', "foo").source().is_none());
    }

    #[test]
    fn test_source_unexpected_eof_error() {
        assert!(ParseError::UnexpectedEof.source().is_none());
    }

    #[test]
    fn test_source_custom_error() {
        assert!(ParseError::custom("foo").source().is_none());
    }

    #[test]
    fn test_source_unmatched_literal_error() {
        assert!(ParseError::unmatched_literal("foo").source().is_none());
    }

    #[test]
    fn test_source_unmatched_choice_error() {
        assert_eq!(
            ParseError::unmatched_choice([
                ParseError::custom("foo"),
                ParseError::UnexpectedEof,
            ])
            .source()
            .unwrap()
            .to_string(),
            "foo"
        );
    }

    #[test]
    fn test_source_unmatched_choice_error_empty() {
        assert!(ParseError::unmatched_choice([]).source().is_none());
    }
}
