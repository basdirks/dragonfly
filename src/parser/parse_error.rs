use std::fmt::Display;

/// Low-level parsing errors.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum ParseError {
    /// A custom error.
    CustomError {
        /// A description of the error.
        message: String,
        /// The input that remains after the error.
        input: String,
    },
    /// Unexpected end of file.
    UnexpectedEof,
    /// The first character of the input can not be parsed.
    ///
    /// aka `ParseError::DaBoiIsNotHappyWithThisOne` -- @Fecony
    UnexpectedChar {
        /// The character that is found.
        actual: char,
        /// A description of the predicate.
        message: String,
    },
    /// None of the given parsers matches the input.
    UnmatchedChoice {
        /// The errors generated by each parser.
        errors: Vec<ParseError>,
    },
    /// The input does not match the given string literal.
    UnmatchedLiteral {
        /// The expected string literal.
        expected: String,
    },
}

impl Display for ParseError {
    fn fmt(
        &self,
        f: &mut std::fmt::Formatter<'_>,
    ) -> std::fmt::Result {
        match self {
            Self::CustomError { message, input } => {
                write!(f, "{message}: {input}")
            }
            Self::UnexpectedEof => write!(f, "Unexpected end of file"),
            Self::UnexpectedChar { actual, message } => {
                write!(f, "Unexpected character '{actual}': {message}")
            }
            Self::UnmatchedChoice { errors } => {
                writeln!(f, "Unmatched choice:")?;

                for error in errors {
                    write!(f, "\n{error}")?;
                }

                Ok(())
            }
            Self::UnmatchedLiteral { expected } => {
                write!(f, "Unmatched literal: {expected}")
            }
        }
    }
}
