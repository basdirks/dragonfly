use std::fmt::Display;

/// Low-level parsing errors.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum ParseError {
    /// A custom error.
    Custom {
        /// A description of the error.
        message: String,
    },
    /// Unexpected end of file.
    UnexpectedEof,
    /// The first character of the input can not be parsed.
    ///
    /// aka `ParseError::DaBoiIsNotHappyWithThisOne` -- @Fecony
    UnexpectedChar {
        /// The character that is found.
        actual: char,
        /// A description of the predicate.
        message: String,
    },
    /// None of the given parsers matches the input.
    UnmatchedChoice {
        /// The errors generated by each parser.
        errors: Vec<ParseError>,
    },
    /// The input does not match the given string literal.
    UnmatchedLiteral {
        /// The expected string literal.
        expected: String,
    },
}

impl Display for ParseError {
    fn fmt(
        &self,
        f: &mut std::fmt::Formatter<'_>,
    ) -> std::fmt::Result {
        match self {
            Self::Custom { message } => {
                write!(f, "{message}")
            }
            Self::UnexpectedEof => write!(f, "Unexpected end of file"),
            Self::UnexpectedChar { actual, message } => {
                write!(f, "Unexpected character '{actual}': {message}")
            }
            Self::UnmatchedChoice { errors } => {
                let error_count = errors.len();

                writeln!(f, "Unmatched choice:")?;

                for (i, error) in errors.iter().enumerate() {
                    let i = i + 1;

                    if i == error_count {
                        write!(f, "{i}. {error}")?;
                    } else {
                        writeln!(f, "{i}. {error}")?;
                    }
                }

                Ok(())
            }
            Self::UnmatchedLiteral { expected } => {
                write!(f, "Unmatched literal: {expected}")
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_display_custom_error() {
        assert_eq!(
            ParseError::Custom {
                message: "foo".to_owned(),
            }
            .to_string(),
            "foo"
        );
    }

    #[test]
    fn test_display_unexpected_eof_error() {
        assert_eq!(
            ParseError::UnexpectedEof.to_string(),
            "Unexpected end of file"
        );
    }

    #[test]
    fn test_display_unexpected_char_error() {
        assert_eq!(
            ParseError::UnexpectedChar {
                actual: 'a',
                message: "foo".to_owned(),
            }
            .to_string(),
            "Unexpected character 'a': foo"
        );
    }

    #[test]
    fn test_display_unmatched_choice_error() {
        assert_eq!(
            ParseError::UnmatchedChoice {
                errors: vec![
                    ParseError::Custom {
                        message: "foo".to_owned(),
                    },
                    ParseError::UnexpectedEof,
                ],
            }
            .to_string(),
            "
            
Unmatched choice:
1. foo
2. Unexpected end of file

"
            .trim()
        );
    }

    #[test]
    fn test_display_unmatched_literal_error() {
        assert_eq!(
            ParseError::UnmatchedLiteral {
                expected: "foo".to_owned(),
            }
            .to_string(),
            "Unmatched literal: foo"
        );
    }
}
